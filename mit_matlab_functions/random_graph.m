% Random graph construction routine with various models% INPUTS:  N - number of nodes%          p - probability, 0<=p<=1%          E - fixed number of edges%          distribution - probability distribution: use the "connecting-stubs model" generation model%          fun - customized pdf function, used only if distribution = 'custom' - used as:%                random_graph(n,p,E,distribution,@myfun,degrees), where myfun is the function name, %                of a fn saved in myfun.m%          degrees - particular degree sequence, used only if distribution = 'sequence'% OUTPUTS: adj - adjacency matrix of generated graph (symmetric)% Note 1: Default is Erdos-Renyi graph G(n,0.5)% Note 2: Can generate a disconnected, multi-edge graph with self-loops - check using isconnected.m/issimple.m% Source: Various random graph models from the literature%% Gergana Bounova, October 31, 2005function adj = random_graph(n,p,E,distribution,fun,degrees)adj=zeros(n); % initialize adjacency matrixswitch nargin    case 1  % just the number of nodes, n        p = 0.5; % default probability of attachment        for i=1:n            for j=i+1:n                if rand<=p                    adj(i,j)=1; adj(j,i)=1;                end            end        end     case 2 % the number of nodes and the probability of attachment, n, p        for i=1:n            for j=i+1:n                if rand<=p                    adj(i,j)=1; adj(j,i)=1;                end            end        end      case 3 % fixed number of nodes and edges, n, E             while numedges(adj) < E            i=ceil(rand*n); j=ceil(rand*n);            if not(i==j) % do not allow self-loops                adj(i,j)=adj(i,j)+1; adj(j,i)=adj(i,j);            end        end        otherwise % pick from a distribution; generate *n* random numbers from a distribution        Nseq=1;  % ensure the while loops start        switch distribution            case 'uniform'                while mod(sum(Nseq),2)==1 % make sure # stubs is even                    Nseq = ceil((n-1)*rand(1,n));                end            case 'normal'                while mod(sum(Nseq),2)==1 % make sure # stubs is even                    Nseq = ceil((n-1)/10*randn(1,n)+(n-1)/2);                end            case 'binomial'                p=0.5;  % default parameter for binomial distribution                while mod(sum(Nseq),2)==1 % make sure # stubs is even                    Nseq = ceil(binornd(n-1,p,1,n));                end            case 'exponential'                while mod(sum(Nseq),2)==1 % make sure # stubs is even                    Nseq = ceil(exprnd(n-1,1,n));                end            case 'geometric'                while mod(sum(Nseq),2)==1 % make sure # stubs is even                    Nseq = ceil(geornd(p,1,n));                end                case 'custom'                % pick a number from a custom pdf function                % generate a random number x between 1 and N-1                % accept it with probability fun(x)                while mod(sum(Nseq),2)==1 % make sure # stubs is even                    Nseq = [];                    while length(Nseq)<n                        x = ceil(rand*(n-1));                        if rand <= fun(x)                            Nseq = [Nseq x];                        end                    end                end            case 'sequence'                Nseq = degrees;        end                   % connect stubs at random        nodes_left = [1:n];        for i=1:n            node{i} = [1:Nseq(i)];        end          while numel(nodes_left)>0   % edges < sum(Nseq)/2                        randi = ceil(rand*length(nodes_left));            nodei = nodes_left(randi);               % pick a random node            randj = ceil(rand*length(node{nodei}));            stubj = node{nodei}(randj);              % pick a random stub                randii = ceil(rand*length(nodes_left));            nodeii = nodes_left(randii);             % pick another random node            randjj = ceil(rand*length(node{nodeii}));            stubjj = node{nodeii}(randjj);           % pick a random stub                % connect two nodes, as longs as stubs different            if not(nodei==nodeii & stubj==stubjj)                % add new links                adj(nodei,nodeii) = adj(nodei,nodeii)+1;                 adj(nodeii,nodei) = adj(nodei,nodeii);                % remove connected stubs                node{nodei} = setdiff(node{nodei},stubj);                node{nodeii} = setdiff(node{nodeii},stubjj);            end                % remove empty nodes            nodes_left1 = nodes_left;            for i=1:length(nodes_left)                if length(node{nodes_left(i)})==0                    nodes_left1 = setdiff(nodes_left1,nodes_left(i));                end            end            nodes_left = nodes_left1;          end      end  % end nargin options%     function pdf_value = fun(x)   ------------ EXAMPLE%         % Custom pdf example function%         % INPUT: variable x%         % OUTPUT: probability that X=x, where X is a random variable from the mypdf distribution%         %%%%%%% Note: to use an external function%         % Gergana Bounova, December 18, 2005% %         % this is an arbitrary function for now, 0<=pdf_value<=1% %         % pdf_value = exp(-x);%         % pdf_value = abs(1/x*exp(-x/100));% %         pdf_value = abs(x/(100+x));