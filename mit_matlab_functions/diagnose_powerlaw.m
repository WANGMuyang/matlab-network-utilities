% Diagnosing a sequence as power-law or not% usage: diagnoseDatafile(numBins)% numBins is the no. of bins used in histogram for logNormal plot% I suggest trying several , e.g. 5, 10, 20, 100...% It pulls in the raw data from 'datafile', which must consist of positive integers.% http://www.elvis.ac.nz/brain?DetectingPowerLaws% INPUTS: sequence x, number of bins% OUTPUTS: gamma - power-law exponent%% Original by Daniel Whitney, slightly modified by Gergana Bounova, 6/28/07function gamma = diagnose_powerlaw(x,numBins)v = find(x>0); x = x(v); % get rid of zeros...v = find(x<10000000); x = x(v); % get rid of huuuuuge numbers...% the generic tests for powerlaws:eventSize=[1:max(x)];eventFreq = histc(x,[1:max(x)]);v = find(eventFreq>0); eventFreq = eventFreq(v); eventSize = eventSize(v); eventFreq = eventFreq';set(gcf,'color',[1,1,1])subplot(221)loglog(eventSize,eventFreq,'rs','markerfacecolor','red')%disp(['There were ',num2str(sum(eventFreq)),' samples generated altogether'])%disp(['The largest sized sample is ',num2str(max(eventSize))])xlabel('event size')ylabel('# times it happened')title('FREQUENCY vs SIZE PLOT')axis squaresubplot(222)x = -sort(-x); % sort into descending orderv = find(x>0); x = x(v); % get rid of zeros...index = [1:length(x)];loglog(index,x,'b.')xlabel('rank of value (in descending order)')ylabel('value')title('EVENTS RANKED BY SIZE')axis squaresubplot(223)[eventFreq,J] = sort(eventFreq);eventSize = eventSize(J);eventSize = -sort(-eventSize); % sort in descending orderrankedRange = [length(eventSize):-1:1];%%%%%%% Regression to find the best-fit distributionxPower = log(rankedRange);yPower = log(eventFreq)';[P1,S1] = polyfit(xPower, yPower, 1);yfitPower = polyval(P1,xPower);%%%%%%loglog(rankedRange,eventFreq,'ks','markerfacecolor','black');hold on;loglog(rankedRange, exp(yfitPower), 'b-', 'linewidth', 2);hold off;xlabel('event rank (according to its freq)')ylabel('# times it happened')title('EVENTS RANKED BY FREQ')axis squaresubplot(224)% And now test for log-normal behaviour:% here's a binned histogram of the log of the raw data:logx = log(x);level = [min(logx): (max(logx)-min(logx))/numBins : max(logx)];count = zeros(1,length(level)-1);for i=1:length(level)-1    count(i) = length(find((logx>level(i)) & (logx<level(i+1))));end% Throw away zero counts again...v = find(count>0); level = level(v); count = count(v); % Cheap and cheerful way to confirm it's a parabola: find max and take% sqrt...% Better: find a weighted mean for the Gaussian, as the max is too noisy...m = sum(level .* count) / sum(count);[dummy, modeIndex] = min(abs(level-m));mm = count(modeIndex); % this is where we think the max SHOULD be!count = min(count, mm); % it's annoying to deal with values that                          % noise makes greater than this...y = log(mm) - log(count);sy = sqrt(y);xval = level-level(modeIndex);negXs = find(xval<0);sy(negXs) = -sy(negXs);%%%%%%% Regression to find the best-fit distributionxLog = xval;yLog = sy;[P2,S2] = polyfit(xLog, yLog, 1);yfitLog = polyval(P2,xLog);%%%%%%plot(xval, sy, 'bs', 'markerfacecolor', 'blue')hold on;plot(xval, yfitLog, 'r-','linewidth', 2);hold off;title('VERY STRAIGHT --> LogNormal')xlabel('dist from mean (in logspace)')ylabel('sqrt of logs of counts of binned log values (-ves reflected)')gamma=P1(1);disp(['Fit for power law:   ', num2str(P1(1)), 'x + ', num2str(P1(2))]);disp(['Fit for log-normal:  ', num2str(P2(1)), 'x + ', num2str(P2(2))]);